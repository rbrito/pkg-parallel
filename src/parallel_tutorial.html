<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>GNU Parallel tutorial</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body style="background-color: white">



<ul id="index">
  <li><a href="#GNU-Parallel-Tutorial">GNU Parallel Tutorial</a></li>
  <li><a href="#Prerequisites">Prerequisites</a></li>
  <li><a href="#Input-sources">Input sources</a>
    <ul>
      <li><a href="#A-single-input-source">A single input source</a></li>
      <li><a href="#Multiple-input-sources">Multiple input sources</a>
        <ul>
          <li><a href="#Matching-arguments-from-all-input-sources">Matching arguments from all input sources</a></li>
        </ul>
      </li>
      <li><a href="#Changing-the-argument-separator">Changing the argument separator.</a></li>
      <li><a href="#Changing-the-argument-delimiter">Changing the argument delimiter</a></li>
      <li><a href="#End-of-file-value-for-input-source">End-of-file value for input source</a></li>
      <li><a href="#Skipping-empty-lines">Skipping empty lines</a></li>
    </ul>
  </li>
  <li><a href="#Building-the-command-line">Building the command line</a>
    <ul>
      <li><a href="#No-command-means-arguments-are-commands">No command means arguments are commands</a></li>
      <li><a href="#Replacement-strings">Replacement strings</a>
        <ul>
          <li><a href="#The-7-predefined-replacement-strings">The 7 predefined replacement strings</a></li>
          <li><a href="#Changing-the-replacement-strings">Changing the replacement strings</a></li>
          <li><a href="#Perl-expression-replacement-string">Perl expression replacement string</a></li>
          <li><a href="#Positional-replacement-strings">Positional replacement strings</a></li>
          <li><a href="#Positional-perl-expression-replacement-string">Positional perl expression replacement string</a></li>
          <li><a href="#Input-from-columns">Input from columns</a></li>
          <li><a href="#Header-defined-replacement-strings">Header defined replacement strings</a></li>
        </ul>
      </li>
      <li><a href="#More-than-one-argument">More than one argument</a></li>
      <li><a href="#Quoting">Quoting</a></li>
      <li><a href="#Trimming-space">Trimming space</a></li>
    </ul>
  </li>
  <li><a href="#Controling-the-output">Controling the output</a>
    <ul>
      <li><a href="#Saving-output-into-files">Saving output into files</a></li>
    </ul>
  </li>
  <li><a href="#Control-the-execution">Control the execution</a>
    <ul>
      <li><a href="#Number-of-simultaneous-jobs">Number of simultaneous jobs</a></li>
      <li><a href="#Interactivity">Interactivity</a></li>
      <li><a href="#Timing">Timing</a></li>
      <li><a href="#Progress">Progress</a></li>
      <li><a href="#Termination">Termination</a></li>
      <li><a href="#Limiting-the-ressources">Limiting the ressources</a></li>
    </ul>
  </li>
  <li><a href="#Remote-execution">Remote execution</a>
    <ul>
      <li><a href="#Sshlogin">Sshlogin</a></li>
      <li><a href="#Transferring-files">Transferring files</a></li>
      <li><a href="#Working-dir">Working dir</a></li>
      <li><a href="#Avoid-overloading-sshd">Avoid overloading sshd</a></li>
      <li><a href="#Ignore-hosts-that-are-down">Ignore hosts that are down</a></li>
      <li><a href="#Running-the-same-commands-on-all-hosts">Running the same commands on all hosts</a></li>
      <li><a href="#Transfer-environment-variables-and-functions">Transfer environment variables and functions</a></li>
      <li><a href="#Showing-what-is-actually-run">Showing what is actually run</a></li>
    </ul>
  </li>
  <li><a href="#pipe">--pipe</a>
    <ul>
      <li><a href="#Chunk-size">Chunk size</a></li>
      <li><a href="#Records">Records</a></li>
      <li><a href="#Record-separators">Record separators</a></li>
      <li><a href="#Header">Header</a></li>
    </ul>
  </li>
  <li><a href="#Shebang">Shebang</a>
    <ul>
      <li><a href="#Input-data-and-parallel-command-in-the-same-file">Input data and parallel command in the same file</a></li>
      <li><a href="#Parallelizing-existing-scripts">Parallelizing existing scripts</a></li>
    </ul>
  </li>
  <li><a href="#Semaphore">Semaphore</a>
    <ul>
      <li><a href="#Counting-semaphore">Counting semaphore</a></li>
    </ul>
  </li>
  <li><a href="#Informational">Informational</a></li>
  <li><a href="#Profiles">Profiles</a></li>
  <li><a href="#Spread-the-word">Spread the word</a></li>
</ul>

<h1 id="GNU-Parallel-Tutorial">GNU Parallel Tutorial</h1>

<p>This tutorial shows off much of GNU Parallel&#39;s functionality. The tutorial is meant to learn the options in GNU Parallel. The tutorial is not to show realistic examples from the real world.</p>

<p>Spend an hour walking through the tutorial. Your command line will love you for it.</p>

<h1 id="Prerequisites">Prerequisites</h1>

<p>To run this tutorial you must have the following:</p>

<dl>

<dt id="parallel-version-20140622">parallel &gt;= version 20140622</dt>
<dd>

<p>Install the newest version with:</p>

<pre><code>  (wget -O - pi.dk/3 || curl pi.dk/3/) | bash</code></pre>

<p>This will also install the newest version of the tutorial:</p>

<pre><code>  man parallel_tutorial</code></pre>

<p>Most of the tutorial will work on older versions, too.</p>

</dd>
<dt id="abc-file">abc-file:</dt>
<dd>

<p>The file can be generated by:</p>

<pre><code>  parallel -k echo ::: A B C &gt; abc-file</code></pre>

</dd>
<dt id="def-file">def-file:</dt>
<dd>

<p>The file can be generated by:</p>

<pre><code>  parallel -k echo ::: D E F &gt; def-file</code></pre>

</dd>
<dt id="abc0-file">abc0-file:</dt>
<dd>

<p>The file can be generated by:</p>

<pre><code>  perl -e &#39;printf &quot;A\0B\0C\0&quot;&#39; &gt; abc0-file</code></pre>

</dd>
<dt id="abc_-file">abc_-file:</dt>
<dd>

<p>The file can be generated by:</p>

<pre><code>  perl -e &#39;printf &quot;A_B_C_&quot;&#39; &gt; abc_-file</code></pre>

</dd>
<dt id="tsv-file.tsv">tsv-file.tsv</dt>
<dd>

<p>The file can be generated by:</p>

<pre><code>  perl -e &#39;printf &quot;f1\tf2\nA\tB\nC\tD\n&quot;&#39; &gt; tsv-file.tsv</code></pre>

</dd>
<dt id="num30000">num30000</dt>
<dd>

<p>The file can be generated by:</p>

<pre><code>  perl -e &#39;for(1..30000){print &quot;$_\n&quot;}&#39; &gt; num30000</code></pre>

</dd>
<dt id="num1000000">num1000000</dt>
<dd>

<p>The file can be generated by:</p>

<pre><code>  perl -e &#39;for(1..1000000){print &quot;$_\n&quot;}&#39; &gt; num1000000</code></pre>

</dd>
<dt id="num_-header">num_%header</dt>
<dd>

<p>The file can be generated by:</p>

<pre><code>  (echo %head1; echo %head2; perl -e &#39;for(1..10){print &quot;$_\n&quot;}&#39;) &gt; num_%header</code></pre>

</dd>
<dt id="For-remote-running:-ssh-login-on-2-servers-with-no-password-in-SERVER1-and-SERVER2">For remote running: ssh login on 2 servers with no password in $SERVER1 and $SERVER2</dt>
<dd>

<pre><code>  SERVER1=server.example.com
  SERVER2=server2.example.net</code></pre>

<p>You must be able to:</p>

<pre><code>  ssh $SERVER1 echo works
  ssh $SERVER2 echo works</code></pre>

<p>It can be setup by running &#39;ssh-keygen -t dsa; ssh-copy-id $SERVER1&#39; and using an empty pass phrase.</p>

</dd>
</dl>

<h1 id="Input-sources">Input sources</h1>

<p>GNU Parallel reads input from input sources. These can be files, the command line, and stdin (standard input or a pipe).</p>

<h2 id="A-single-input-source">A single input source</h2>

<p>Input can be read from the command line:</p>

<pre><code>  parallel echo ::: A B C</code></pre>

<p>Output (the order may be different because the jobs are run in parallel):</p>

<pre><code>  A
  B
  C</code></pre>

<p>The input source can be a file:</p>

<pre><code>  parallel -a abc-file echo</code></pre>

<p>Output: Same as above.</p>

<p>STDIN (standard input) can be the input source:</p>

<pre><code>  cat abc-file | parallel echo</code></pre>

<p>Output: Same as above.</p>

<h2 id="Multiple-input-sources">Multiple input sources</h2>

<p>GNU Parallel can take multiple input sources given on the command line. GNU Parallel then generates all combinations of the input sources:</p>

<pre><code>  parallel echo ::: A B C ::: D E F</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  A D
  A E
  A F
  B D
  B E
  B F
  C D
  C E
  C F</code></pre>

<p>The input sources can be files:</p>

<pre><code>  parallel -a abc-file -a def-file echo</code></pre>

<p>Output: Same as above.</p>

<p>STDIN (standard input) can be one of the input sources using &#39;-&#39;:</p>

<pre><code>  cat abc-file | parallel -a - -a def-file echo </code></pre>

<p>Output: Same as above.</p>

<p>Instead of -a files can be given after &#39;::::&#39;:</p>

<pre><code>  cat abc-file | parallel echo :::: - def-file</code></pre>

<p>Output: Same as above.</p>

<p>::: and :::: can be mixed:</p>

<pre><code>  parallel echo ::: A B C :::: def-file</code></pre>

<p>Output: Same as above.</p>

<h3 id="Matching-arguments-from-all-input-sources">Matching arguments from all input sources</h3>

<p>With --xapply you can get one argument from each input source:</p>

<pre><code>  parallel --xapply echo ::: A B C ::: D E F</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  A D
  B E
  C F</code></pre>

<p>If one of the input sources is too short, its values will wrap:</p>

<pre><code>  parallel --xapply echo ::: A B C D E ::: F G</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  A F
  B G
  C F
  D G
  E F</code></pre>

<h2 id="Changing-the-argument-separator">Changing the argument separator.</h2>

<p>GNU Parallel can use other separators than ::: or ::::. This is typically useful if ::: or :::: is used in the command to run:</p>

<pre><code>  parallel --arg-sep ,, echo ,, A B C :::: def-file</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  A D
  A E
  A F
  B D
  B E
  B F
  C D
  C E
  C F</code></pre>

<p>Changing the argument file separator:</p>

<pre><code>  parallel --arg-file-sep // echo ::: A B C // def-file</code></pre>

<p>Output: Same as above.</p>

<h2 id="Changing-the-argument-delimiter">Changing the argument delimiter</h2>

<p>GNU Parallel will normally treat a full line as a single argument: It uses \n as argument delimiter. This can be changed with -d:</p>

<pre><code>  parallel -d _ echo :::: abc_-file</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  A
  B
  C</code></pre>

<p>NULL can be given as \0:</p>

<pre><code>  parallel -d &#39;\0&#39; echo :::: abc0-file</code></pre>

<p>Output: Same as above.</p>

<p>A shorthand for -d &#39;\0&#39; is -0 (this will often be used to read files from find ... -print0):</p>

<pre><code>  parallel -0 echo :::: abc0-file</code></pre>

<p>Output: Same as above.</p>

<h2 id="End-of-file-value-for-input-source">End-of-file value for input source</h2>

<p>GNU Parallel can stop reading when it encounters a certain value:</p>

<pre><code>  parallel -E stop echo ::: A B stop C D</code></pre>

<p>Output:</p>

<pre><code>  A
  B</code></pre>

<h2 id="Skipping-empty-lines">Skipping empty lines</h2>

<p>Using --no-run-if-empty GNU Parallel will skip empty lines.</p>

<pre><code>  (echo 1; echo; echo 2) | parallel --no-run-if-empty echo</code></pre>

<p>Output:</p>

<pre><code>  1
  2</code></pre>

<h1 id="Building-the-command-line">Building the command line</h1>

<h2 id="No-command-means-arguments-are-commands">No command means arguments are commands</h2>

<p>If no command is given after parallel the arguments themselves are treated as commands:</p>

<pre><code>  parallel ::: ls &#39;echo foo&#39; pwd</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  [list of files in current dir]
  foo
  [/path/to/current/working/dir]</code></pre>

<p>The command can be a script, a binary or a Bash function if the function is exported using &#39;export -f&#39;:</p>

<pre><code>  # Only works in Bash and only if $SHELL=.../bash
  my_func() {
    echo in my_func $1
  }
  export -f my_func
  parallel my_func ::: 1 2 3</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  in my_func 1
  in my_func 2
  in my_func 3</code></pre>

<h2 id="Replacement-strings">Replacement strings</h2>

<h3 id="The-7-predefined-replacement-strings">The 7 predefined replacement strings</h3>

<p>GNU Parallel has several replacement strings. If no replacement strings are used the default is to append {}:</p>

<pre><code>  parallel echo ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  A/B.C</code></pre>

<p>The default replacement string is {}:</p>

<pre><code>  parallel echo {} ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  A/B.C</code></pre>

<p>The replacement string {.} removes the extension:</p>

<pre><code>  parallel echo {.} ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  A/B</code></pre>

<p>The replacement string {/} removes the path:</p>

<pre><code>  parallel echo {/} ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  B.C</code></pre>

<p>The replacement string {//} keeps only the path:</p>

<pre><code>  parallel echo {//} ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  A</code></pre>

<p>The replacement string {/.} removes the path and the extension:</p>

<pre><code>  parallel echo {/.} ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  B</code></pre>

<p>The replacement string {#} gives the job number:</p>

<pre><code>  parallel echo {#} ::: A B C</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  1
  2
  3</code></pre>

<p>The replacement string {%} gives the job slot number (between 1 and number of jobs to run in parallel):</p>

<pre><code>  parallel -j 2 echo {%} ::: A B C</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  1
  2
  1</code></pre>

<h3 id="Changing-the-replacement-strings">Changing the replacement strings</h3>

<p>The replacement string {} can be changed with -I:</p>

<pre><code>  parallel -I ,, echo ,, ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  A/B.C</code></pre>

<p>The replacement string {.} can be changed with --extensionreplace:</p>

<pre><code>  parallel --extensionreplace ,, echo ,, ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  A/B</code></pre>

<p>The replacement string {/} can be replaced with --basenamereplace:</p>

<pre><code>  parallel --basenamereplace ,, echo ,, ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  B.C</code></pre>

<p>The replacement string {//} can be changed with --dirnamereplace:</p>

<pre><code>  parallel --dirnamereplace ,, echo ,, ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  A</code></pre>

<p>The replacement string {/.} can be changed with --basenameextensionreplace:</p>

<pre><code>  parallel --basenameextensionreplace ,, echo ,, ::: A/B.C</code></pre>

<p>Output:</p>

<pre><code>  B</code></pre>

<p>The replacement string {#} can be changed with --seqreplace:</p>

<pre><code>  parallel --seqreplace ,, echo ,, ::: A B C</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  1
  2
  3</code></pre>

<p>The replacement string {%} can be changed with --slotreplace:</p>

<pre><code>  parallel -j2 --slotreplace ,, echo ,, ::: A B C</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  1
  2
  1</code></pre>

<h3 id="Perl-expression-replacement-string">Perl expression replacement string</h3>

<p>When predefined replacement strings are not flexible enough a perl expression can be used instead. One example is to remove two extensions: foo.tar.gz -&gt; foo</p>

<pre><code>   parallel echo &#39;{= s:\.[^.]+$::;s:\.[^.]+$::; =}&#39; ::: foo.tar.gz</code></pre>

<p>Output:</p>

<pre><code>   foo</code></pre>

<p>If the strings <b>{=</b> and <b>=}</b> cause problems they can be replaced with --parens:</p>

<pre><code>   parallel --parens ,,,, echo &#39;,, s:\.[^.]+$::;s:\.[^.]+$::; ,,&#39; ::: foo.tar.gz</code></pre>

<p>Output: Same as above.</p>

<p>To define a short hand replacement string use <b>--rpl</b>:</p>

<pre><code>   parallel --rpl &#39;.. s:\.[^.]+$::;s:\.[^.]+$::;&#39; echo &#39;..&#39; ::: foo.tar.gz</code></pre>

<p>Output: Same as above.</p>

<p>If the short hand starts with &#39;{&#39; it can be used as a positional replacement string, too:</p>

<pre><code>   parallel --rpl &#39;{..} s:\.[^.]+$::;s:\.[^.]+$::;&#39; echo &#39;{..}&#39; ::: foo.tar.gz</code></pre>

<p>Output: Same as above.</p>

<p>GNU <b>parallel</b>&#39;s 7 replacement strings are implemented as:</p>

<pre><code>  --rpl &#39;{} &#39;
  --rpl &#39;{#} $_=$job-&gt;seq()&#39;
  --rpl &#39;{%} $_=$job-&gt;slot()&#39;
  --rpl &#39;{/} s:.*/::&#39;
  --rpl &#39;{//} $Global::use{&quot;File::Basename&quot;} ||= eval &quot;use File::Basename; 1;&quot;; $_ = dirname($_);&#39;
  --rpl &#39;{/.} s:.*/::; s:\.[^/.]+$::;&#39;
  --rpl &#39;{.} s:\.[^/.]+$::&#39;</code></pre>

<h3 id="Positional-replacement-strings">Positional replacement strings</h3>

<p>With multiple input sources the argument from the individual input sources can be access with {number}:</p>

<pre><code>  parallel echo {1} and {2} ::: A B ::: C D</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  A and C
  A and D
  B and C
  B and D</code></pre>

<p>The positional replacement strings can also be modified using / // /. and .:</p>

<pre><code>  parallel echo /={1/} //={1//} /.={1/.} .={1.} ::: A/B.C D/E.F</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  /=B.C //=A /.=B .=A/B
  /=E.F //=D /.=E .=D/E</code></pre>

<p>If a position is negative, it will refer to the input source counted from behind:</p>

<pre><code>  parallel echo 1={1} 2={2} 3={3} -1={-1} -2={-2} -3={-3} ::: A B ::: C D ::: E F</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  1=A 2=C 3=E -1=E -2=C -3=A
  1=A 2=C 3=F -1=F -2=C -3=A
  1=A 2=D 3=E -1=E -2=D -3=A
  1=A 2=D 3=F -1=F -2=D -3=A
  1=B 2=C 3=E -1=E -2=C -3=B
  1=B 2=C 3=F -1=F -2=C -3=B
  1=B 2=D 3=E -1=E -2=D -3=B
  1=B 2=D 3=F -1=F -2=D -3=B</code></pre>

<h3 id="Positional-perl-expression-replacement-string">Positional perl expression replacement string</h3>

<p>To use a perl expression as a positional replacement string simply prepend the perl expression with number and space:</p>

<pre><code>   parallel echo &#39;{=2 s:\.[^.]+$::;s:\.[^.]+$::; =} {1}&#39; ::: bar ::: foo.tar.gz</code></pre>

<p>Output:</p>

<pre><code>   foo bar</code></pre>

<p>If a defined short hand starts with &#39;{&#39; it can be used as a positional replacement string, too:</p>

<pre><code>   parallel --rpl &#39;{..} s:\.[^.]+$::;s:\.[^.]+$::;&#39; echo &#39;{2..} {1}&#39; ::: bar ::: foo.tar.gz</code></pre>

<p>Output: Same as above.</p>

<h3 id="Input-from-columns">Input from columns</h3>

<p>The columns in a file can be bound to positional replacement strings using --colsep. Here the columns are separated with TAB (\t):</p>

<pre><code>  parallel --colsep &#39;\t&#39; echo 1={1} 2={2} :::: tsv-file.tsv</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  1=f1 2=f2
  1=A 2=B
  1=C 2=D</code></pre>

<h3 id="Header-defined-replacement-strings">Header defined replacement strings</h3>

<p>With --header GNU Parallel will use the first value of the input source as the name of the replacement string. Only the non-modified version {} is supported:</p>

<pre><code>  parallel --header : echo f1={f1} f2={f2} ::: f1 A B ::: f2 C D</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  f1=A f2=C
  f1=A f2=D
  f1=B f2=C
  f1=B f2=D</code></pre>

<p>It is useful with --colsep for processing files with TAB separated values:</p>

<pre><code>  parallel --header : --colsep &#39;\t&#39; echo f1={f1} f2={f2} :::: tsv-file.tsv</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  f1=A f2=B
  f1=C f2=D</code></pre>

<h2 id="More-than-one-argument">More than one argument</h2>

<p>With --xargs will GNU Parallel fit as many arguments as possible on a single line:</p>

<pre><code>  cat num30000 | parallel --xargs echo | wc -l</code></pre>

<p>Output:</p>

<pre><code>  2</code></pre>

<p>The 30000 arguments fitted on 2 lines.</p>

<p>The maximal length of a single line can be set with -s. With a maximal line length of 10000 chars 17 commands will be run:</p>

<pre><code>  cat num30000 | parallel --xargs -s 10000 echo | wc -l</code></pre>

<p>Output:</p>

<pre><code>  17</code></pre>

<p>For better parallelism GNU Parallel can distribute the arguments between all the parallel jobs when end of file is met.</p>

<p>Below GNU Parallel reads the last argument when generating the second job. When GNU Parallel reads the last argument, it spreads all the arguments for the second job over 4 jobs instead, as 4 parallel jobs are requested.</p>

<p>The first job will be the same as the --xargs example above, but the second job will be split into 4 evenly sized jobs, resulting in a total of 5 jobs:</p>

<pre><code>  cat num30000 | parallel --jobs 4 -m echo | wc -l</code></pre>

<p>Output:</p>

<pre><code>  5</code></pre>

<p>This is even more visible when running 4 jobs with 10 arguments. The 10 arguments are being spread over 4 jobs:</p>

<pre><code>  parallel --jobs 4 -m echo ::: {1..10}</code></pre>

<p>Output:</p>

<pre><code>  1 2 3
  4 5 6
  7 8 9
  10</code></pre>

<p>A replacement string can be part of a word. -m will not repeat the context:</p>

<pre><code>  parallel --jobs 4 -m echo pre-{}-post ::: A B C D E F G</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  pre-A B-post
  pre-C D-post
  pre-E F-post
  pre-G-post</code></pre>

<p>To repeat the context use -X which otherwise works like -m:</p>

<pre><code>  parallel --jobs 4 -X echo pre-{}-post ::: A B C D E F G</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  pre-A-post pre-B-post
  pre-C-post pre-D-post
  pre-E-post pre-F-post
  pre-G-post</code></pre>

<p>To limit the number of arguments use -N:</p>

<pre><code>  parallel -N3 echo ::: A B C D E F G H</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  A B C
  D E F
  G H</code></pre>

<p>-N also sets the positional replacement strings:</p>

<pre><code>  parallel -N3 echo 1={1} 2={2} 3={3} ::: A B C D E F G H</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  1=A 2=B 3=C
  1=D 2=E 3=F
  1=G 2=H 3=</code></pre>

<p>-N0 reads 1 argument but inserts none:</p>

<pre><code>  parallel -N0 echo foo ::: 1 2 3</code></pre>

<p>Output:</p>

<pre><code>  foo
  foo
  foo</code></pre>

<h2 id="Quoting">Quoting</h2>

<p>Command lines that contain special characters may need to be protected from the shell.</p>

<p>The perl program &#39;print &quot;@ARGV\n&quot;&#39; basically works like echo.</p>

<pre><code>  perl -e &#39;print &quot;@ARGV\n&quot;&#39; A</code></pre>

<p>Output:</p>

<pre><code>  A</code></pre>

<p>To run that in parallel the command needs to be quoted:</p>

<pre><code>  parallel perl -e &#39;print &quot;@ARGV\n&quot;&#39; ::: This wont work</code></pre>

<p>Output:</p>

<pre><code>  [Nothing]</code></pre>

<p>To quote the command use -q:</p>

<pre><code>  parallel -q perl -e &#39;print &quot;@ARGV\n&quot;&#39; ::: This works</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  This
  works</code></pre>

<p>Or you can quote the critical part using \&#39;:</p>

<pre><code>  parallel perl -e \&#39;&#39;print &quot;@ARGV\n&quot;&#39;\&#39; ::: This works, too</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  This
  works,
  too</code></pre>

<p>GNU Parallel can also \-quote full lines. Simply run:</p>

<pre><code>  parallel --shellquote
  parallel: Warning: Input is read from the terminal. Only experts do this on purpose. Press CTRL-D to exit.
  perl -e &#39;print &quot;@ARGV\n&quot;&#39;
  [CTRL-D]</code></pre>

<p>Output:</p>

<pre><code>  perl\ -e\ \&#39;print\ \&quot;@ARGV\\n\&quot;\&#39;</code></pre>

<p>This can then be used as the command:</p>

<pre><code>  parallel perl\ -e\ \&#39;print\ \&quot;@ARGV\\n\&quot;\&#39; ::: This also works</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  This
  also
  works</code></pre>

<h2 id="Trimming-space">Trimming space</h2>

<p>Space can be trimmed on the arguments using --trim:</p>

<pre><code>  parallel --trim r echo pre-{}-post ::: &#39; A &#39;</code></pre>

<p>Output:</p>

<pre><code>  pre- A-post</code></pre>

<p>To trim on the left side:</p>

<pre><code>  parallel --trim l echo pre-{}-post ::: &#39; A &#39;</code></pre>

<p>Output:</p>

<pre><code>  pre-A -post</code></pre>

<p>To trim on the both sides:</p>

<pre><code>  parallel --trim lr echo pre-{}-post ::: &#39; A &#39;</code></pre>

<p>Output:</p>

<pre><code>  pre-A-post</code></pre>

<h1 id="Controling-the-output">Controling the output</h1>

<p>The output can prefixed with the argument:</p>

<pre><code>  parallel --tag echo foo-{} ::: A B C</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  A       foo-A
  B       foo-B
  C       foo-C</code></pre>

<p>To prefix it with another string use --tagstring:</p>

<pre><code>  parallel --tagstring {}-bar echo foo-{} ::: A B C</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  A-bar   foo-A
  B-bar   foo-B
  C-bar   foo-C</code></pre>

<p>To see what commands will be run without running them:</p>

<pre><code>  parallel --dryrun echo {} ::: A B C</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  echo A
  echo B
  echo C</code></pre>

<p>To print the command before running them use --verbose:</p>

<pre><code>  parallel --verbose echo {} ::: A B C</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  echo A
  echo B
  A
  echo C
  B
  C</code></pre>

<p>GNU Parallel will postpone the output until the command completes:</p>

<pre><code>  parallel -j2 &#39;printf &quot;%s-start\n%s&quot; {} {};sleep {};printf &quot;%s\n&quot; -middle;echo {}-end&#39; ::: 4 2 1</code></pre>

<p>Output:</p>

<pre><code>  2-start
  2-middle
  2-end
  1-start
  1-middle
  1-end
  4-start
  4-middle
  4-end</code></pre>

<p>To get the output immediately use --ungroup:</p>

<pre><code>  parallel -j2 --ungroup &#39;printf &quot;%s-start\n%s&quot; {} {};sleep {};printf &quot;%s\n&quot; -middle;echo {}-end&#39; ::: 4 2 1      </code></pre>

<p>Output:</p>

<pre><code>  4-start
  42-start
  2-middle
  2-end
  1-start
  1-middle
  1-end
  -middle
  4-end</code></pre>

<p>--ungroup is fast, but can cause half a line from one job to be mixed with half a line of another job. That has happend in the second line, where the line &#39;4-middle&#39; is mixed with &#39;2-start&#39;.</p>

<p>To avoid this use --linebuffer:</p>

<pre><code>  parallel -j2 --linebuffer &#39;printf &quot;%s-start\n%s&quot; {} {};sleep {};printf &quot;%s\n&quot; -middle;echo {}-end&#39; ::: 4 2 1</code></pre>

<p>Output:</p>

<pre><code>  4-start
  2-start
  2-middle
  2-end
  1-start
  1-middle
  1-end
  4-middle
  4-end</code></pre>

<p>To force the output in the same order as the arguments use --keep-order/-k:</p>

<pre><code>  parallel -j2 -k &#39;printf &quot;%s-start\n%s&quot; {} {};sleep {};printf &quot;%s\n&quot; -middle;echo {}-end&#39; ::: 4 2 1</code></pre>

<p>Output:</p>

<pre><code>  4-start
  4-middle
  4-end
  2-start
  2-middle
  2-end
  1-start
  1-middle
  1-end</code></pre>

<h2 id="Saving-output-into-files">Saving output into files</h2>

<p>GNU Parallel can save the output of each job into files:</p>

<pre><code>  parallel --files echo ::: A B C</code></pre>

<p>Output will be similar to:</p>

<pre><code>  /tmp/pAh6uWuQCg.par
  /tmp/opjhZCzAX4.par
  /tmp/W0AT_Rph2o.par</code></pre>

<p>By default GNU Parallel will cache the output in files in /tmp. This can be changed by setting $TMPDIR or --tmpdir:</p>

<pre><code>  parallel --tmpdir /var/tmp --files echo ::: A B C</code></pre>

<p>Output will be similar to:</p>

<pre><code>  /var/tmp/N_vk7phQRc.par
  /var/tmp/7zA4Ccf3wZ.par
  /var/tmp/LIuKgF_2LP.par</code></pre>

<p>Or:</p>

<pre><code>  TMPDIR=/var/tmp parallel --files echo ::: A B C</code></pre>

<p>Output: Same as above.</p>

<p>The output files can be saved in a structured way using --results:</p>

<pre><code>  parallel --results outdir echo ::: A B C</code></pre>

<p>Output:</p>

<pre><code>  A
  B
  C</code></pre>

<p>but also these files were generated containing the standard output (stdout) and standard error (stderr):</p>

<pre><code>  outdir/1/A/stderr
  outdir/1/A/stdout
  outdir/1/B/stderr
  outdir/1/B/stdout
  outdir/1/C/stderr
  outdir/1/C/stdout</code></pre>

<p>This is useful if you are running multiple variables:</p>

<pre><code>  parallel --header : --results outdir echo ::: f1 A B ::: f2 C D</code></pre>

<p>Generated files:</p>

<pre><code>  outdir/f1/A/f2/C/stderr
  outdir/f1/A/f2/C/stdout
  outdir/f1/A/f2/D/stderr
  outdir/f1/A/f2/D/stdout
  outdir/f1/B/f2/C/stderr
  outdir/f1/B/f2/C/stdout
  outdir/f1/B/f2/D/stderr
  outdir/f1/B/f2/D/stdout</code></pre>

<p>The directories are named after the variables and their values.</p>

<h1 id="Control-the-execution">Control the execution</h1>

<h2 id="Number-of-simultaneous-jobs">Number of simultaneous jobs</h2>

<p>The number of concurrent jobs is given with --jobs/-j:</p>

<pre><code>  /usr/bin/time parallel -N0 -j64 sleep 1 ::: {1..128}</code></pre>

<p>With 64 jobs in parallel the 128 sleeps will take 2-8 seconds to run - depending on how fast your machine is.</p>

<p>By default --jobs is the same as the number of CPU cores. So this:</p>

<pre><code>  /usr/bin/time parallel -N0 sleep 1 ::: {1..128}</code></pre>

<p>should take twice the time of running 2 jobs per CPU core:</p>

<pre><code>  /usr/bin/time parallel -N0 --jobs 200% sleep 1 ::: {1..128}</code></pre>

<p>--jobs 0 will run as many jobs in parallel as possible:</p>

<pre><code>  /usr/bin/time parallel -N0 --jobs 0 sleep 1 ::: {1..128}</code></pre>

<p>which should take 1-7 seconds depending on how fast your machine is.</p>

<p>--jobs can read from a file which is re-read when a job finishes:</p>

<pre><code>  echo 50% &gt; my_jobs
  /usr/bin/time parallel -N0 --jobs my_jobs sleep 1 ::: {1..128} &amp;
  sleep 1
  echo 0 &gt; my_jobs
  wait</code></pre>

<p>The first second only 50% of the CPU cores will run a job. The &#39;0&#39; is put into my_jobs and then the rest of the jobs will be started in parallel.</p>

<p>Instead of basing the percentage on the number of CPU cores GNU Parallel can base it on the number of CPUs:</p>

<pre><code>  parallel --use-cpus-instead-of-cores -N0 sleep 1 ::: {1..128}</code></pre>

<h2 id="Interactivity">Interactivity</h2>

<p>GNU Parallel can ask the user if a command should be run using --interactive:</p>

<pre><code>  parallel --interactive echo ::: 1 2 3</code></pre>

<p>Output:</p>

<pre><code>  echo 1 ?...y
  echo 2 ?...n
  1
  echo 3 ?...y
  3</code></pre>

<p>GNU Parallel can be used to put arguments on the command line for an interactive command such as emacs to edit one file at a time:</p>

<pre><code>  parallel --tty emacs ::: 1 2 3</code></pre>

<p>Or give multiple argument in one go to open multiple files:</p>

<pre><code>  parallel -X --tty vi ::: 1 2 3</code></pre>

<h2 id="Timing">Timing</h2>

<p>Some jobs do heavy I/O when they start. To avoid a thundering herd GNU Parallel can delay starting new jobs. --delay X will make sure there is at least X seconds between each start:</p>

<pre><code>  parallel --delay 2.5 echo Starting {}\;date ::: 1 2 3</code></pre>

<p>Output:</p>

<pre><code>  Starting 1
  Thu Aug 15 16:24:33 CEST 2013
  Starting 2
  Thu Aug 15 16:24:35 CEST 2013
  Starting 3
  Thu Aug 15 16:24:38 CEST 2013</code></pre>

<p>If jobs taking more than a certain amount of time are known to fail, they can be stopped with --timeout:</p>

<pre><code>  parallel --timeout 2.1 sleep {}\; echo {} ::: 1 2 3 4</code></pre>

<p>Output:</p>

<pre><code>  1
  2</code></pre>

<p>GNU Parallel can compute the median runtime for jobs and kill those that take more than 200% of the median runtime:</p>

<pre><code>  parallel --timeout 200% sleep {}\; echo {} ::: 2.1 2.2 3 7 2.3</code></pre>

<p>Output:</p>

<pre><code>  2.1
  2.2
  3
  2.3</code></pre>

<p>Based on the runtime of completed jobs GNU Parallel can estimate the total runtime:</p>

<pre><code>  parallel --eta sleep ::: 1 3 2 2 1 3 3 2 1</code></pre>

<p>Output:</p>

<pre><code>  Computers / CPU cores / Max jobs to run
  1:local / 2 / 2

  Computer:jobs running/jobs completed/%of started jobs/Average seconds to complete
  ETA: 2s 0left 1.11avg  local:0/9/100%/1.1s </code></pre>

<h2 id="Progress">Progress</h2>

<p>GNU Parallel can give progress information with --progress:</p>

<pre><code>  parallel --progress sleep ::: 1 3 2 2 1 3 3 2 1</code></pre>

<p>Output:</p>

<pre><code>  Computers / CPU cores / Max jobs to run
  1:local / 2 / 2

  Computer:jobs running/jobs completed/%of started jobs/Average seconds to complete
  local:0/9/100%/1.1s</code></pre>

<p>A logfile of the jobs completed so far can be generated with --joblog:</p>

<pre><code>  parallel --joblog /tmp/log exit  ::: 1 2 3 0 
  cat /tmp/log</code></pre>

<p>Output:</p>

<pre><code>  Seq     Host    Starttime       Runtime Send    Receive Exitval Signal  Command
  1       :       1376577364.974  0.008   0       0       1       0       exit 1
  2       :       1376577364.982  0.013   0       0       2       0       exit 2
  3       :       1376577364.990  0.013   0       0       3       0       exit 3
  4       :       1376577365.003  0.003   0       0       0       0       exit 0</code></pre>

<p>The log contains the job sequence, which host the job was run on, the start time and run time, how much data was transferred if the job was run on a remote host, the exit value, the signal that killed the job, and finally the command being run.</p>

<p>With a joblog GNU Parallel can be stopped and later pickup where it left off. It it important that the input of the completed jobs is unchanged.</p>

<pre><code>  parallel --joblog /tmp/log exit  ::: 1 2 3 0 
  cat /tmp/log
  parallel --resume --joblog /tmp/log exit  ::: 1 2 3 0 0 0
  cat /tmp/log</code></pre>

<p>Output:</p>

<pre><code>  Seq     Host    Starttime       Runtime Send    Receive Exitval Signal  Command
  1       :       1376580069.544  0.008   0       0       1       0       exit 1
  2       :       1376580069.552  0.009   0       0       2       0       exit 2
  3       :       1376580069.560  0.012   0       0       3       0       exit 3
  4       :       1376580069.571  0.005   0       0       0       0       exit 0

  Seq     Host    Starttime       Runtime Send    Receive Exitval Signal  Command
  1       :       1376580069.544  0.008   0       0       1       0       exit 1
  2       :       1376580069.552  0.009   0       0       2       0       exit 2
  3       :       1376580069.560  0.012   0       0       3       0       exit 3
  4       :       1376580069.571  0.005   0       0       0       0       exit 0
  5       :       1376580070.028  0.009   0       0       0       0       exit 0
  6       :       1376580070.038  0.007   0       0       0       0       exit 0</code></pre>

<p>Note how the start time of the last 2 jobs is clearly from the second run.</p>

<p>With --resume-failed GNU Parallel will re-run the jobs that failed:</p>

<pre><code>  parallel --resume-failed --joblog /tmp/log exit  ::: 1 2 3 0 0 0
  cat /tmp/log</code></pre>

<p>Output:</p>

<pre><code>  Seq     Host    Starttime       Runtime Send    Receive Exitval Signal  Command
  1       :       1376580069.544  0.008   0       0       1       0       exit 1
  2       :       1376580069.552  0.009   0       0       2       0       exit 2
  3       :       1376580069.560  0.012   0       0       3       0       exit 3
  4       :       1376580069.571  0.005   0       0       0       0       exit 0
  5       :       1376580070.028  0.009   0       0       0       0       exit 0
  6       :       1376580070.038  0.007   0       0       0       0       exit 0
  1       :       1376580154.433  0.010   0       0       1       0       exit 1
  2       :       1376580154.444  0.022   0       0       2       0       exit 2
  3       :       1376580154.466  0.005   0       0       3       0       exit 3</code></pre>

<p>Note how seq 1 2 3 have been repeated because they had exit value != 0.</p>

<h2 id="Termination">Termination</h2>

<p>For certain jobs there is no need to continue if one of the jobs fails and has an exit code != 0. GNU Parallel will stop spawning new jobs with --halt 1:</p>

<pre><code>  parallel -j2 --halt 1 echo {}\; exit {} ::: 0 0 1 2 3</code></pre>

<p>Output:</p>

<pre><code>  0
  0
  1
  parallel: Starting no more jobs. Waiting for 2 jobs to finish. This job failed:
  echo 1; exit 1
  2
  parallel: Starting no more jobs. Waiting for 1 jobs to finish. This job failed:
  echo 2; exit 2</code></pre>

<p>With --halt 2 the running jobs will be killed immediately:</p>

<pre><code>  parallel -j2 --halt 2 echo {}\; exit {} ::: 0 0 1 2 3</code></pre>

<p>Output:</p>

<pre><code>  0
  0
  1
  parallel: This job failed:
  echo 1; exit 1</code></pre>

<p>If --halt is given a percentage this percentage of the jobs must fail (though minimum 3) before GNU Parallel stops spawning more jobs:</p>

<pre><code>  parallel -j2 --halt 20% echo {}\; exit {} ::: 0 0 1 2 3 4 5 6 7</code></pre>

<p>Output:</p>

<pre><code>  0
  0
  1
  2
  3
  4
  parallel: Starting no more jobs. Waiting for 2 jobs to finish. This job failed:
      echo 4; exit 4
  5
  parallel: Starting no more jobs. Waiting for 1 jobs to finish. This job failed:
      echo 5; exit 5</code></pre>

<p>GNU Parallel can retry the command with --retries. This is useful if a command fails for unkown reasons now and then.</p>

<pre><code>  parallel -k --retries 3 &#39;echo tried {} &gt;&gt;/tmp/runs; echo completed {}; exit {}&#39; ::: 1 2 0
  cat /tmp/runs</code></pre>

<p>Output:</p>

<pre><code>  completed 1
  completed 2
  completed 0

  tried 1
  tried 2
  tried 1
  tried 2
  tried 1
  tried 2
  tried 0</code></pre>

<p>Note how job 1 and 2 were tried 3 times, but 0 was not retried because it had exit code 0.</p>

<h2 id="Limiting-the-ressources">Limiting the ressources</h2>

<p>To avoid overloading systems GNU Parallel can look at the system load before starting another job:</p>

<pre><code>  parallel --load 100% echo load is less than {} job per cpu ::: 1 </code></pre>

<p>Output:</p>

<pre><code>  [when then load is less than the number of cpu cores]
  load is less than 1 job per cpu</code></pre>

<p>GNU Parallel can also check if the system is swapping.</p>

<pre><code>  parallel --noswap echo the system is not swapping ::: now</code></pre>

<p>Output:</p>

<pre><code>  [when then system is not swapping]
  the system is not swapping now</code></pre>

<p>GNU Parallel can run the jobs with a nice value. This will work both locally and remotely.</p>

<pre><code>  parallel --nice 17 echo this is being run with nice -n ::: 17</code></pre>

<p>Output:</p>

<pre><code>  this is being run with nice -n 17</code></pre>

<h1 id="Remote-execution">Remote execution</h1>

<p>GNU Parallel can run jobs on remote servers. It uses ssh to communicate with the remote machines.</p>

<h2 id="Sshlogin">Sshlogin</h2>

<p>The most basic sshlogin is -S host:</p>

<pre><code>  parallel -S $SERVER1 echo running on ::: $SERVER1</code></pre>

<p>Output:</p>

<pre><code>  running on [$SERVER1]</code></pre>

<p>To use a different username prepend the server with username@</p>

<pre><code>  parallel -S username@$SERVER1 echo running on ::: username@$SERVER1</code></pre>

<p>Output:</p>

<pre><code>  running on [username@$SERVER1]</code></pre>

<p>The special sshlogin &#39;:&#39; is the local machine:</p>

<pre><code>  parallel -S : echo running on ::: the_local_machine</code></pre>

<p>Output:</p>

<pre><code>  running on the_local_machine</code></pre>

<p>If ssh is not in $PATH it can be prepended to $SERVER1:</p>

<pre><code>  parallel -S &#39;/usr/bin/ssh &#39;$SERVER1 echo custom ::: ssh</code></pre>

<p>Output:</p>

<pre><code>  custom ssh</code></pre>

<p>Several servers can be given using multiple -S:</p>

<pre><code>  parallel -S $SERVER1 -S $SERVER2 echo ::: running on more hosts</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  running
  on
  more
  hosts</code></pre>

<p>Or they can be separated by ,:</p>

<pre><code>  parallel -S $SERVER1,$SERVER2 echo ::: running on more hosts</code></pre>

<p>Output: Same as above.</p>

<p>The can also be read from a file (replace user@ with the user on $SERVER2):</p>

<pre><code>  echo $SERVER1 &gt; nodefile
  # Force 4 cores, special ssh-command, username
  echo 4//usr/bin/ssh user@$SERVER2 &gt;&gt; nodefile
  parallel --sshloginfile nodefile echo ::: running on more hosts</code></pre>

<p>Output: Same as above.</p>

<p>The special --sshloginfile &#39;..&#39; reads from ~/.parallel/sshloginfile.</p>

<p>To force GNU Parallel to treat a server having a given number of CPU cores prepend #/ to the sshlogin:</p>

<pre><code>  parallel -S 4/$SERVER1 echo force {} cpus on server ::: 4</code></pre>

<p>Output:</p>

<pre><code>  force 4 cpus on server</code></pre>

<h2 id="Transferring-files">Transferring files</h2>

<p>GNU Parallel can transfer the files to be processed to the remote host. It does that using rsync.</p>

<pre><code>  echo This is input_file &gt; input_file
  parallel -S $SERVER1 --transfer cat ::: input_file </code></pre>

<p>Output:</p>

<pre><code>  This is input_file</code></pre>

<p>If the files is processed into another file, the resulting file can be transferred back:</p>

<pre><code>  echo This is input_file &gt; input_file
  parallel -S $SERVER1 --transfer --return {}.out cat {} &quot;&gt;&quot;{}.out ::: input_file 
  cat input_file.out</code></pre>

<p>Output: Same as above.</p>

<p>To remove the input and output file on the remote server use --cleanup:</p>

<pre><code>  echo This is input_file &gt; input_file
  parallel -S $SERVER1 --transfer --return {}.out --cleanup cat {} &quot;&gt;&quot;{}.out ::: input_file 
  cat input_file.out</code></pre>

<p>Output: Same as above.</p>

<p>There is a short hand for --transfer --return --cleanup called --trc:</p>

<pre><code>  echo This is input_file &gt; input_file
  parallel -S $SERVER1 --trc {}.out cat {} &quot;&gt;&quot;{}.out ::: input_file 
  cat input_file.out</code></pre>

<p>Output: Same as above.</p>

<p>Some jobs need a common database for all jobs. GNU Parallel can transfer that using --basefile which will transfer the file before the first job:</p>

<pre><code>  echo common data &gt; common_file
  parallel --basefile common_file -S $SERVER1 cat common_file\; echo {} ::: foo
  </code></pre>

<p>Output:</p>

<pre><code>  common data
  foo</code></pre>

<p>To remove it from the remote host after the last job use --cleanup.</p>

<h2 id="Working-dir">Working dir</h2>

<p>The default working dir on the remote machines is the login dir. This can be changed with --workdir <i>mydir</i>.</p>

<p>Files transferred using --transfer and --return will be relative to <i>mydir</i> on remote computers, and the command will be executed in the dir <i>mydir</i>.</p>

<p>The special <i>mydir</i> value ... will create working dirs under ~/.parallel/tmp/ on the remote computers. If --cleanup is given these dirs will be removed.</p>

<p>The special <i>mydir</i> value . uses the current working dir. If the current working dir is beneath your home dir, the value . is treated as the relative path to your home dir. This means that if your home dir is different on remote computers (e.g. if your login is different) the relative path will still be relative to your home dir.</p>

<pre><code>  parallel -S $SERVER1 pwd ::: &quot;&quot;
  parallel --workdir . -S $SERVER1 pwd ::: &quot;&quot;
  parallel --workdir ... -S $SERVER1 pwd ::: &quot;&quot;</code></pre>

<p>Output:</p>

<pre><code>  [the login dir on $SERVER1]
  [current dir relative on $SERVER1]
  [a dir in ~/.parallel/tmp/...]</code></pre>

<h2 id="Avoid-overloading-sshd">Avoid overloading sshd</h2>

<p>If many jobs are started on the same server, sshd can be overloaded. GNU Parallel can insert a delay between each job run on the same server:</p>

<pre><code>  parallel -S $SERVER1 --sshdelay 0.2 echo ::: 1 2 3</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  1
  2
  3</code></pre>

<p>Sshd will be less overloaded if using --controlmaster, which will multiplex ssh connections:</p>

<pre><code>  parallel --controlmaster -S $SERVER1 echo ::: 1 2 3</code></pre>

<p>Output: Same as above.</p>

<h2 id="Ignore-hosts-that-are-down">Ignore hosts that are down</h2>

<p>In clusters with many hosts a few of the are often down. GNU Parallel can ignore those hosts. In this case the host 173.194.32.46 is down:</p>

<pre><code>  parallel --filter-hosts -S 173.194.32.46,$SERVER1 echo ::: bar </code></pre>

<p>Output:</p>

<pre><code>  bar</code></pre>

<h2 id="Running-the-same-commands-on-all-hosts">Running the same commands on all hosts</h2>

<p>GNU Parallel can run the same command on all the hosts:</p>

<pre><code>  parallel --onall -S $SERVER1,$SERVER2 echo ::: foo bar</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  foo
  bar
  foo
  bar</code></pre>

<p>Often you will just want to run a single command on all hosts with out arguments. --nonall is a no argument --onall:</p>

<pre><code>  parallel --nonall -S $SERVER1,$SERVER2 echo foo bar</code></pre>

<p>Output:</p>

<pre><code>  foo bar
  foo bar</code></pre>

<p>When --tag is used with --nonall and --onall the --tagstring is the host:</p>

<pre><code>  parallel --nonall --tag -S $SERVER1,$SERVER2 echo foo bar</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  $SERVER1 foo bar
  $SERVER2 foo bar</code></pre>

<p>--jobs sets the number of servers to log in to in parallel.</p>

<h2 id="Transfer-environment-variables-and-functions">Transfer environment variables and functions</h2>

<p>Using --env GNU Parallel can transfer an environment variable to the remote system.</p>

<pre><code>  MYVAR=&#39;foo bar&#39;
  export MYVAR
  parallel --env MYVAR -S $SERVER1 echo &#39;$MYVAR&#39; ::: baz</code></pre>

<p>Output:</p>

<pre><code>  foo bar baz</code></pre>

<p>This works for functions too if your shell is Bash:</p>

<pre><code>  # This only works in Bash
  my_func() {
    echo in my_func $1
  }
  export -f my_func
  parallel --env my_func -S $SERVER1 my_func ::: baz</code></pre>

<p>Output:</p>

<pre><code>  in my_func baz</code></pre>

<p>GNU Parallel can copy all defined variables and functions to the remote system. It just needs to record which ones to ignore in ~/.parallel/ignored_vars. Do that by running this once:</p>

<pre><code>  parallel --record-env
  cat ~/.parallel/ignored_vars</code></pre>

<p>Output:</p>

<pre><code>  [list of variables to ignore - including $PATH and $HOME]</code></pre>

<p>Now all new variables and functions defined will be copied when using --env _:</p>

<pre><code>  # The function is only copied if using Bash
  my_func2() {
    echo in my_func2 $VAR $1
  }
  export -f my_func2
  VAR=foo
  export VAR

  parallel --env _ -S $SERVER1 &#39;echo $VAR; my_func2&#39; ::: bar</code></pre>

<p>Output:</p>

<pre><code>  foo
  in my_func2 foo bar</code></pre>

<h2 id="Showing-what-is-actually-run">Showing what is actually run</h2>

<p>--verbose will show the command that would be run on the local machine. When a job is run on a remote machine this is wrapped with ssh and possibly transferring files and environment variables, setting the workdir, and setting --nice value. -vv shows all of this.</p>

<pre><code>  parallel -vv -S $SERVER1 echo ::: bar</code></pre>

<p>Output:</p>

<pre><code>  ssh -tt -oLogLevel=quiet lo  &#39;eval `echo $SHELL | grep &quot;/t\{0,1\}csh&quot; &gt; /dev/null  &amp;&amp; echo setenv PARALLEL_SEQ &#39;$PARALLEL_SEQ&#39;\;  setenv PARALLEL_PID &#39;$PARALLEL_PID&#39;  || echo PARALLEL_SEQ=&#39;$PARALLEL_SEQ&#39;\;export PARALLEL_SEQ\;  PARALLEL_PID=&#39;$PARALLEL_PID&#39;\;export PARALLEL_PID` ;&#39;  tty\ \&gt;/dev/null\ \&amp;\&amp;\ stty\ isig\ -onlcr\ -echo\;echo\ bar;
  bar</code></pre>

<p>When the command gets more complex, the output is so hard to read, that it is only useful for debugging:</p>

<pre><code>  my_func3() {
    echo in my_func $1 &gt; $1.out
  }
  export -f my_func3
  parallel -vv --workdir ... --nice 17 --env _ --trc {}.out -S $SERVER1 my_func3 {} ::: abc-file</code></pre>

<p>Output will be similar to:</p>

<pre><code>  ssh server mkdir -p .parallel/tmp/hk-31483-1; rsync -rlDzR -essh ./abc-file server:.parallel/tmp/hk-31483-1;ssh -tt -oLogLevel=quiet server  &#39;eval `echo $SHELL | grep &quot;/t\{0,1\}csh&quot; &gt; /dev/null  &amp;&amp; echo setenv PARALLEL_SEQ &#39;$PARALLEL_SEQ&#39;\;  setenv PARALLEL_PID &#39;$PARALLEL_PID&#39;  || echo PARALLEL_SEQ=&#39;$PARALLEL_SEQ&#39;\;export PARALLEL_SEQ\;  PARALLEL_PID=&#39;$PARALLEL_PID&#39;\;export PARALLEL_PID` ;&#39;  tty\ \&gt;/dev/null\ \&amp;\&amp;\ stty\ isig\ -onlcr\ -echo\;mkdir\ -p\ .parallel/tmp/hk-31483-1\;\ cd\ .parallel/tmp/hk-31483-1\ \&amp;\&amp;\ echo\ \$SHELL\ \|\ grep\ \&quot;/t\\\{0,1\\\}csh\&quot;\ \&gt;\ /dev/null\ \&amp;\&amp;\ setenv\ my_func3\ \\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func\\\ \\\$1\\\ \\\&gt;\\\ \\\$1.out\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ setenv\ VAR\ foo\ \&amp;\&amp;\ setenv\ my_func2\ \\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func2\\\ \\\$VAR\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \|\|\ export\ my_func3=\\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func\\\ \\\$1\\\ \\\&gt;\\\ \\\$1.out\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ export\ VAR=foo\ \&amp;\&amp;\ export\ my_func2=\\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func2\\\ \\\$VAR\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ eval\ my_func3\&quot;\$my_func3\&quot;\ \&amp;\&amp;\ eval\ my_func2\&quot;\$my_func2\&quot;\;\\nice\ -n17\ /bin/bash\ -c\ my_func3\\\ abc-file;_EXIT_status=$?; mkdir -p .; rsync --rsync-path=cd\ .parallel/tmp/hk-31483-1/.\;\ rsync -rlDzR -essh server:abc-file.out .;ssh server rm\ -f\ .parallel/tmp/hk-31483-1/abc-file\;rm\ -f\ .parallel/tmp/hk-31483-1/abc-file.out\;rm -rf .parallel/tmp/hk-31483-1\;; exit $_EXIT_status;</code></pre>

<h1 id="pipe">--pipe</h1>

<p>The --pipe functionality puts GNU Parallel in a different mode: Instead of treating the data on stdin (standard input) as arguments for a command to run, the data will be sent to stdin (standard input) of the command.</p>

<p>The typical situation is:</p>

<pre><code>  command_A | command_B | command_C</code></pre>

<p>where command_B is slow, and you want to speed up command_B.</p>

<h2 id="Chunk-size">Chunk size</h2>

<p>By default GNU Parallel will start an instance of command_B, read a chunk of 1 MB, and pass that to the instance. Then start another instance, read another chunk, and pass that to the second instance.</p>

<pre><code>  cat num1000000 | parallel --pipe wc</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  165668  165668 1048571
  149797  149797 1048579
  149796  149796 1048572
  149797  149797 1048579
  149797  149797 1048579
  149796  149796 1048572
   85349   85349  597444</code></pre>

<p>The size of the chunk is not exactly 1 MB because GNU Parallel only passes full lines - never half a line, thus the blocksize is only average 1 MB. You can change the block size to 2 MB with --block:</p>

<pre><code>  cat num1000000 | parallel --pipe --block 2M wc</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  315465  315465 2097150
  299593  299593 2097151
  299593  299593 2097151
   85349   85349  597444</code></pre>

<p>GNU Parallel treats each line as a record. If the order of record is unimportant (e.g. you need all lines processed, but you do not care which is processed first), then you can use --round-robin. Without --round-robin GNU Parallel will start a command per block; with --round-robin only the requested number of jobs will be started (--jobs). The records will then be distributed between the running jobs:</p>

<pre><code>  cat num1000000 | parallel --pipe -j4 --round-robin wc</code></pre>

<p>Output will be similar to:</p>

<pre><code>  149797  149797 1048579
  299593  299593 2097151
  315465  315465 2097150
  235145  235145 1646016</code></pre>

<p>One of the 4 instances got a single record, 2 instances got 2 full records each, and one instance got 1 full and 1 partial record.</p>

<h2 id="Records">Records</h2>

<p>GNU Parallel sees the input as records. The default record is a single line.</p>

<p>Using -N140000 GNU Parallel will read 140000 records at a time:</p>

<pre><code>  cat num1000000 | parallel --pipe -N140000 wc</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  140000  140000  868895
  140000  140000  980000
  140000  140000  980000
  140000  140000  980000
  140000  140000  980000
  140000  140000  980000
  140000  140000  980000
   20000   20000  140001</code></pre>

<p>Notice that the last job could not get the full 140000 lines, but only 20000 lines.</p>

<p>If a record is 75 lines -L can be used:</p>

<pre><code>  cat num1000000 | parallel --pipe -L75 wc</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  165600  165600 1048095
  149850  149850 1048950
  149775  149775 1048425
  149775  149775 1048425
  149850  149850 1048950
  149775  149775 1048425
   85350   85350  597450
      25      25     176</code></pre>

<p>Notice GNU Parallel still reads a block of around 1 MB; but instead of passing full lines to &#39;wc&#39; it passes full 75 lines at a time. This of course does not hold for the last job (which in this case got 25 lines).</p>

<h2 id="Record-separators">Record separators</h2>

<p>GNU Parallel uses separators to determine where two record split.</p>

<p>--recstart gives the string that starts a record; --recend gives the string that ends a record. The default is --recend &#39;\n&#39; (newline).</p>

<p>If both --recend and --recstart are given, then the record will only split if the recend string is immediately followed by the recstart string.</p>

<p>Here the --recend is set to &#39;, &#39;:</p>

<pre><code>  echo /foo, bar/, /baz, qux/, | parallel -kN1 --recend &#39;, &#39; --pipe echo JOB{#}\;cat\;echo END</code></pre>

<p>Output:</p>

<pre><code>  JOB1
  /foo, END
  JOB2
  bar/, END
  JOB3
  /baz, END
  JOB4
  qux/,
  END</code></pre>

<p>Here the --recstart is set to &#39;/&#39;:</p>

<pre><code>  echo /foo, bar/, /baz, qux/, | parallel -kN1 --recstart &#39;/&#39; --pipe echo JOB{#}\;cat\;echo END</code></pre>

<p>Output:</p>

<pre><code>  JOB1
  /foo, barEND
  JOB2
  /, END
  JOB3
  /baz, quxEND
  JOB4
  /,
  END</code></pre>

<p>Here both --recend and --recstart are set:</p>

<pre><code>  echo /foo, bar/, /baz, qux/, | parallel -kN1 --recend &#39;, &#39; --recstart &#39;/&#39; --pipe echo JOB{#}\;cat\;echo END</code></pre>

<p>Output:</p>

<pre><code>  JOB1
  /foo, bar/, END
  JOB2
  /baz, qux/,
  END</code></pre>

<p>Note the difference between setting one string and setting both strings.</p>

<p>With --regexp the --recend and --recstart will be treated as a regular expression:</p>

<pre><code>  echo foo,bar,_baz,__qux, | parallel -kN1 --regexp --recend &#39;,_+&#39; --pipe echo JOB{#}\;cat\;echo END</code></pre>

<p>Output:</p>

<pre><code>  JOB1
  foo,bar,_END
  JOB2
  baz,__END
  JOB3
  qux,
  END</code></pre>

<p>GNU Parallel can remove the record separators with --remove-rec-sep/--rrs:</p>

<pre><code>  echo foo,bar,_baz,__qux, | parallel -kN1 --rrs --regexp --recend &#39;,_+&#39; --pipe echo JOB{#}\;cat\;echo END</code></pre>

<p>Output:</p>

<pre><code>  JOB1
  foo,barEND
  JOB2
  bazEND
  JOB3
  qux,
  END</code></pre>

<h2 id="Header">Header</h2>

<p>If the input data has a header, the header can be repeated for each job by matching the header with --header. If headers start with %:</p>

<pre><code>  cat num_%header | parallel --header &#39;(%.*\n)*&#39; --pipe -N3 echo JOB{#}\;cat</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  JOB1
  %head1
  %head2
  1
  2
  3
  JOB2
  %head1
  %head2
  4
  5
  6
  JOB3
  %head1
  %head2
  7
  8
  9
  JOB4
  %head1
  %head2
  10</code></pre>

<p>If the header is 2 lines, --header 2 will work:</p>

<pre><code>  cat num_%header | parallel --header 2 --pipe -N3 echo JOB{#}\;cat</code></pre>

<p>Output: Same as above.</p>

<h1 id="Shebang">Shebang</h1>

<h2 id="Input-data-and-parallel-command-in-the-same-file">Input data and parallel command in the same file</h2>

<p>GNU Parallel is often called as:</p>

<pre><code>  cat input_file | parallel command</code></pre>

<p>With --shebang the input_file and parallel can be combined into the same script.</p>

<p>UNIX-scripts start with a shebang line like:</p>

<pre><code>  #!/bin/bash</code></pre>

<p>GNU Parallel can do that, too. With --shebang the arguments can be listed in the file. The parallel command is the first line of the script:</p>

<pre><code>  #!/usr/bin/parallel --shebang -r echo

  foo
  bar
  baz</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  foo
  bar
  baz</code></pre>

<h2 id="Parallelizing-existing-scripts">Parallelizing existing scripts</h2>

<p>GNU Parallel is often called as:</p>

<pre><code>  cat input_file | parallel command
  parallel command ::: foo bar</code></pre>

<p>If command is a script parallel can be combined into a single file so:</p>

<pre><code>  cat input_file | command
  command foo bar</code></pre>

<p>will run the script in parallel.</p>

<p>This perl script perl_echo works like echo:</p>

<pre><code>  #!/usr/bin/perl

  print &quot;@ARGV\n&quot;</code></pre>

<p>It can be called as:</p>

<pre><code>  parallel perl_echo ::: foo bar</code></pre>

<p>By changing the #!-line it can be run in parallel</p>

<pre><code>  #!/usr/bin/parallel --shebang-wrap /usr/bin/perl

  print &quot;@ARGV\n&quot;</code></pre>

<p>Thus this will work:</p>

<pre><code>  perl_echo foo bar</code></pre>

<p>Output (the order may be different):</p>

<pre><code>  foo
  bar</code></pre>

<p>This technique can be used for:</p>

<dl>

<dt id="Perl">Perl:</dt>
<dd>

<p>#!/usr/bin/parallel --shebang-wrap /usr/bin/perl</p>

</dd>
<dt id="Python">Python:</dt>
<dd>

<p>#!/usr/bin/parallel --shebang-wrap /usr/bin/python</p>

</dd>
<dt id="Bash">Bash:</dt>
<dd>

<p>#!/usr/bin/parallel --shebang-wrap /bin/bash</p>

</dd>
<dt id="R">R:</dt>
<dd>

<p>#!/usr/bin/parallel --shebang-wrap /usr/bin/Rscript --vanilla --slave</p>

</dd>
<dt id="GNUplot">GNUplot:</dt>
<dd>

<p>#!/usr/bin/parallel --shebang-wrap ARG={} /usr/bin/gnuplot</p>

</dd>
<dt id="Ruby">Ruby:</dt>
<dd>

<p>#!/usr/bin/parallel --shebang-wrap /usr/bin/ruby</p>

</dd>
</dl>

<h1 id="Semaphore">Semaphore</h1>

<p>GNU Parallel can work as a counting semaphore. This is slower and less efficient than its normal mode.</p>

<p>An alias for &#39;parallel --semaphore&#39; is &#39;sem&#39;. The default is to allow only one program to run at a time (technically called a mutex). The program is started in the background. Use --wait for all &#39;sem&#39;s to finish:</p>

<pre><code>  sem &#39;sleep 1; echo The first finished&#39; &amp;&amp;
    echo The first is now running in the background &amp;&amp;
    sem &#39;sleep 1; echo The second finished&#39; &amp;&amp;
    echo The second is now running in the background
  sem --wait</code></pre>

<p>Output:</p>

<pre><code>  The first is now running in the background
  The first finished
  The second is now running in the background
  The second finished</code></pre>

<p>The command can be run in the foreground with --fg:</p>

<pre><code>  sem --fg &#39;sleep 1; echo The first finished&#39; &amp;&amp;
    echo The first finished running in the foreground &amp;&amp;
    sem --fg &#39;sleep 1; echo The second finished&#39; &amp;&amp;
    echo The second finished running in the foreground
  sem --wait</code></pre>

<p>The difference between this and just running the command, is that a mutex is set, so if other sems were running in the background only one would run at the same time.</p>

<p>To tell the difference between which semaphore is used, use --semaphorename/--id. Run this in one terminal:</p>

<pre><code>  sem --id my_id -u &#39;echo First started; sleep 10; echo The first finished&#39;</code></pre>

<p>and simultaneously this in another terminal:</p>

<pre><code>  sem --id my_id -u &#39;echo Second started; sleep 10; echo The second finished&#39;</code></pre>

<p>Note how the second will only be started when the first has finished.</p>

<h2 id="Counting-semaphore">Counting semaphore</h2>

<p>A mutex is like having a single toilet: When it is in use everyone else will have to wait. A counting semaphore is like having multiple toilets: Several people can use the toilets, but when they all are in use, everyone else will have to wait.</p>

<p>sem can emulate a counting semaphore. Use --jobs to set the number of toilets:</p>

<pre><code>  sem --jobs 3 --id my_id -u &#39;echo First started; sleep 5; echo The first finished&#39; &amp;&amp;
  sem --jobs 3 --id my_id -u &#39;echo Second started; sleep 6; echo The second finished&#39; &amp;&amp;
  sem --jobs 3 --id my_id -u &#39;echo Third started; sleep 7; echo The third finished&#39; &amp;&amp;
  sem --jobs 3 --id my_id -u &#39;echo Fourth started; sleep 8; echo The fourth finished&#39; &amp;&amp;
  sem --wait --id my_id</code></pre>

<p>Output:</p>

<pre><code>  First started
  Second started
  Third started
  The first finished
  Fourth started
  The second finished
  The third finished
  The fourth finished</code></pre>

<h1 id="Informational">Informational</h1>

<p>GNU Parallel has some options to give short information about the configuration.</p>

<p>--help will print a summary of the most important options:</p>

<pre><code>  parallel --help</code></pre>

<p>Output:</p>

<pre><code>  Usage:
  parallel [options] [command [arguments]] &lt; list_of_arguments
  parallel [options] [command [arguments]] (::: arguments|:::: argfile(s))...
  cat ... | parallel --pipe [options] [command [arguments]]
  
  -j n           Run n jobs in parallel
  -k             Keep same order
  -X             Multiple arguments with context replace
  --colsep regexp      Split input on regexp for positional replacements
  {} {.} {/} {/.} {#}  Replacement strings
  {3} {3.} {3/} {3/.}  Positional replacement strings
  
  -S sshlogin    Example: foo@server.example.com
  --slf ..       Use ~/.parallel/sshloginfile as the list of sshlogins
  --trc {}.bar   Shorthand for --transfer --return {}.bar --cleanup
  --onall        Run the given command with argument on all sshlogins
  --nonall       Run the given command with no arguments on all sshlogins
  
  --pipe         Split stdin (standard input) to multiple jobs.
  --recend str   Record end separator for --pipe.
  --recstart str Record start separator for --pipe.
  
  See &#39;man parallel&#39; for details
  
  When using GNU Parallel for a publication please cite:
  
  O. Tange (2011): GNU Parallel - The Command-Line Power Tool,
  ;login: The USENIX Magazine, February 2011:42-47.</code></pre>

<p>When asking for help, always report the full output of:</p>

<pre><code>  parallel --version</code></pre>

<p>Output:</p>

<pre><code>  GNU parallel 20130822
  Copyright (C) 2007,2008,2009,2010,2011,2012,2013 Ole Tange and Free Software Foundation, Inc.
  License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
  This is free software: you are free to change and redistribute it.
  GNU parallel comes with no warranty.
  
  Web site: http://www.gnu.org/software/parallel
  
  When using GNU Parallel for a publication please cite:
  
  O. Tange (2011): GNU Parallel - The Command-Line Power Tool, 
  ;login: The USENIX Magazine, February 2011:42-47.</code></pre>

<p>In scripts --minversion can be used to ensure the user has at least this version:</p>

<pre><code>  parallel --minversion 20130722 &amp;&amp; echo Your version is at least 20130722.</code></pre>

<p>Output:</p>

<pre><code>  20130722
  Your version is at least 20130722.</code></pre>

<p>If using GNU Parallel for research the BibTeX citation can be generated using --bibtex.</p>

<pre><code>  parallel --bibtex</code></pre>

<p>Output:</p>

<pre><code>  @article{Tange2011a,
   title = {GNU Parallel - The Command-Line Power Tool},
   author = {O. Tange},
   address = {Frederiksberg, Denmark},
   journal = {;login: The USENIX Magazine},
   month = {Feb},
   number = {1},
   volume = {36},
   url = {http://www.gnu.org/s/parallel},
   year = {2011},
   pages = {42-47}
  }</code></pre>

<p>With --max-line-length-allowed GNU Parallel will report the maximal size of the command line:</p>

<pre><code>  parallel --max-line-length-allowed</code></pre>

<p>Output (may vary on different systems):</p>

<pre><code>  131071</code></pre>

<p>--number-of-cpus and --number-of-cores run system specific code to determine the number of CPUs and CPU cores on the system. On unsupported platforms they will return 1:</p>

<pre><code>  parallel --number-of-cpus 
  parallel --number-of-cores</code></pre>

<p>Output (may vary on different systems):</p>

<pre><code>  4
  64</code></pre>

<h1 id="Profiles">Profiles</h1>

<p>The defaults for GNU Parallel can be changed systemwise by putting the command line options in /etc/parallel/config. They can be changed for a user by putting them in ~/.parallel/config.</p>

<p>Profiles work the same way, but have to be referred to with --profile:</p>

<pre><code>  echo &#39;-S :,&#39;$SERVER1 &gt; ~/.parallel/cluster
  echo &#39;--nice 17&#39; &gt;&gt; ~/.parallel/cluster
  echo &#39;--filter-hosts&#39; &gt;&gt; ~/.parallel/cluster
  echo &#39;--timeout 300%&#39; &gt;&gt; ~/.parallel/cluster
  echo &#39;--env _&#39; &gt;&gt; ~/.parallel/cluster
  parallel --profile cluster echo ::: A B C</code></pre>

<p>Output:</p>

<pre><code>  A
  B
  C</code></pre>

<p>Profiles can be combined:</p>

<pre><code>  echo &#39;-vv --dry-run&#39; &gt; ~/.parallel/dryverbose
  parallel --profile dryverbose --profile cluster echo ::: A B C</code></pre>

<p>Output:</p>

<pre><code>  ssh -tt -oLogLevel=quiet lo  &#39;eval `echo $SHELL | grep &quot;/t\{0,1\}csh&quot; &gt; /dev/null  &amp;&amp; echo setenv PARALLEL_SEQ &#39;$PARALLEL_SEQ&#39;\;  setenv PARALLEL_PID &#39;$PARALLEL_PID&#39;  || echo PARALLEL_SEQ=&#39;$PARALLEL_SEQ&#39;\;export PARALLEL_SEQ\;  PARALLEL_PID=&#39;$PARALLEL_PID&#39;\;export PARALLEL_PID` ;&#39;  tty\ \&gt;/dev/null\ \&amp;\&amp;\ stty\ isig\ -onlcr\ -echo\;echo\ \$SHELL\ \|\ grep\ \&quot;/t\\\{0,1\\\}csh\&quot;\ \&gt;\ /dev/null\ \&amp;\&amp;\ setenv\ SERVER1\ lo\ \&amp;\&amp;\ setenv\ MYVAR\ foo\\\ bar\ \&amp;\&amp;\ setenv\ VAR\ foo\ \&amp;\&amp;\ setenv\ my_func\ \\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ setenv\ my_func2\ \\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func2\\\ \\\$VAR\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \|\|\ export\ SERVER1=lo\ \&amp;\&amp;\ export\ MYVAR=foo\\\ bar\ \&amp;\&amp;\ export\ VAR=foo\ \&amp;\&amp;\ export\ my_func=\\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ export\ my_func2=\\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func2\\\ \\\$VAR\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ eval\ my_func\&quot;\$my_func\&quot;\ \&amp;\&amp;\ eval\ my_func2\&quot;\$my_func2\&quot;\;\\nice\ -n17\ /bin/bash\ -c\ echo\\\ A;
  ssh -tt -oLogLevel=quiet lo  &#39;eval `echo $SHELL | grep &quot;/t\{0,1\}csh&quot; &gt; /dev/null  &amp;&amp; echo setenv PARALLEL_SEQ &#39;$PARALLEL_SEQ&#39;\;  setenv PARALLEL_PID &#39;$PARALLEL_PID&#39;  || echo PARALLEL_SEQ=&#39;$PARALLEL_SEQ&#39;\;export PARALLEL_SEQ\;  PARALLEL_PID=&#39;$PARALLEL_PID&#39;\;export PARALLEL_PID` ;&#39;  tty\ \&gt;/dev/null\ \&amp;\&amp;\ stty\ isig\ -onlcr\ -echo\;echo\ \$SHELL\ \|\ grep\ \&quot;/t\\\{0,1\\\}csh\&quot;\ \&gt;\ /dev/null\ \&amp;\&amp;\ setenv\ SERVER1\ lo\ \&amp;\&amp;\ setenv\ MYVAR\ foo\\\ bar\ \&amp;\&amp;\ setenv\ VAR\ foo\ \&amp;\&amp;\ setenv\ my_func\ \\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ setenv\ my_func2\ \\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func2\\\ \\\$VAR\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \|\|\ export\ SERVER1=lo\ \&amp;\&amp;\ export\ MYVAR=foo\\\ bar\ \&amp;\&amp;\ export\ VAR=foo\ \&amp;\&amp;\ export\ my_func=\\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ export\ my_func2=\\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func2\\\ \\\$VAR\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ eval\ my_func\&quot;\$my_func\&quot;\ \&amp;\&amp;\ eval\ my_func2\&quot;\$my_func2\&quot;\;\\nice\ -n17\ /bin/bash\ -c\ echo\\\ B;
  ssh -tt -oLogLevel=quiet lo  &#39;eval `echo $SHELL | grep &quot;/t\{0,1\}csh&quot; &gt; /dev/null  &amp;&amp; echo setenv PARALLEL_SEQ &#39;$PARALLEL_SEQ&#39;\;  setenv PARALLEL_PID &#39;$PARALLEL_PID&#39;  || echo PARALLEL_SEQ=&#39;$PARALLEL_SEQ&#39;\;export PARALLEL_SEQ\;  PARALLEL_PID=&#39;$PARALLEL_PID&#39;\;export PARALLEL_PID` ;&#39;  tty\ \&gt;/dev/null\ \&amp;\&amp;\ stty\ isig\ -onlcr\ -echo\;echo\ \$SHELL\ \|\ grep\ \&quot;/t\\\{0,1\\\}csh\&quot;\ \&gt;\ /dev/null\ \&amp;\&amp;\ setenv\ SERVER1\ lo\ \&amp;\&amp;\ setenv\ MYVAR\ foo\\\ bar\ \&amp;\&amp;\ setenv\ VAR\ foo\ \&amp;\&amp;\ setenv\ my_func\ \\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ setenv\ my_func2\ \\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func2\\\ \\\$VAR\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \|\|\ export\ SERVER1=lo\ \&amp;\&amp;\ export\ MYVAR=foo\\\ bar\ \&amp;\&amp;\ export\ VAR=foo\ \&amp;\&amp;\ export\ my_func=\\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ export\ my_func2=\\\(\\\)\\\ \\\{\\\ \\\ echo\\\ in\\\ my_func2\\\ \\\$VAR\\\ \\\$1\&quot;&#39;
  &#39;\&quot;\\\}\ \&amp;\&amp;\ eval\ my_func\&quot;\$my_func\&quot;\ \&amp;\&amp;\ eval\ my_func2\&quot;\$my_func2\&quot;\;\\nice\ -n17\ /bin/bash\ -c\ echo\\\ C;</code></pre>

<h1 id="Spread-the-word">Spread the word</h1>

<p>I hope you have learned something from this tutorial.</p>

<p>If you like GNU Parallel:</p>

<ul>

<li><p>(Re-)walk through the tutorial if you have not done so in the past year (http://www.gnu.org/software/parallel/parallel_tutorial.html)</p>

</li>
<li><p>Give a demo at your local user group/team/colleagues</p>

</li>
<li><p>Post the intro videos and the tutorial on Reddit, Diaspora*, forums, blogs, Identi.ca, Google+, Twitter, Facebook, Linkedin, mailing lists</p>

</li>
<li><p>Request or write a review for your favourite blog or magazine</p>

</li>
<li><p>Invite me for your next conference</p>

</li>
</ul>

<p>If you use GNU Parallel for research:</p>

<ul>

<li><p>Please cite GNU Parallel in you publications (use --bibtex)</p>

</li>
</ul>

<p>If GNU Parallel saves you money:</p>

<ul>

<li><p>(Have your company) donate to FSF or become a member https://my.fsf.org/donate/</p>

</li>
</ul>

<p>(C) 2013,2014 Ole Tange, GPLv3</p>


</body>

</html>


